#!/bin/bash
# NAME       : partition_drive_helper.sh
# 
# DESCRIPTION: This is a helper script generated by the Ansible ZFS on Root
#           script showing how the partitions on your drivers were created.
#
#           Should you need to replace a drive or add new drives, you would
#           likely want to partition them in the same way as your existing 
#           drives.
# AUTHOR     : Richard J. Durso
# DATE       : 08/15/2020
# VERSION    : 0.30
#############################################################################

# ---------------------------------------------------------------------------
# Define device name to use:
DISK_DEVICE=/dev/disk/by-id/PUT_YOUR_DEVICE_NAME_HERE
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------
# DANGER: This script does not wipe existing disk partitions.  However, Should
#         you choose to accept this mission, you must uncomment the value
#         below and set it to TRUE.

# ENABLE_PARTITION_WIPE=FALSE
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------
# WARNING: This script does not update your /etc/fstab to use new UUID values
#          for a new device being added.  This should be manually performed.
#          However, if you want the script to attempt it, you must uncomment
#          the value below and set it to TRUE.

# ENABLE_FSTAB_FILE_UPDATES=FALSE
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------
ZFS_BPOOL_NAME={{boot_pool_name}}
ZFS_RPOOL_NAME={{root_pool_name}}
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------
BIOS_PARTITION="-part1"
SWAP_PARTITION="-part2"
BOOT_PARTITION="{{boot_partition_name_suffix}}"
ROOT_PARTITION="{{root_partition_name_suffix}}"
MDADM_SWAP_DEVICE="/dev/md0"
UEFI_PARTITION_FLAGS="{{ uefi_partition_flags }}"
BIOS_PARTITION_FLAGS="{{ bios_partition_flags }}"
SWAP_PARTITION_FLAGS="{{(boot_pool_type == 'raidz')|ternary(raidz_multi_disk_swap_flags, single_disk_or_mirror_swap_flags)}}"
BOOT_POOL_PARTITION_FLAGS="{{(boot_pool_type == 'raidz')|ternary(raidz_multi_disk_boot_partition_flags,single_disk_or_mirror_boot_partition_flags)}}"
ROOT_POOL_PARTITION_FLAGS="{{ root_partition_flags }}"
# ---------------------------------------------------------------------------

# ---[ Usage Statement ]-----------------------------------------------------
__usage() {
  echo "
  zfs_on_root Partitioning Helper Script
  ---------------------------------------------------------------------------
  The flags set in this script were specific to this installation at the time
  the zfs_on_root script was executed.  This should not be executed on other
  systems.

  DISK_DEVICE set to: ${DISK_DEVICE}
 
  Try to detect the path name of the new new device:
  ${0##*/} -d

  To check device exists and has no partitions:
  ${0##*/} -c

  To WIPE, DELETE, REMOVE, DESTROY, ZAP, ELIMINATE device partitions:
  ${0##*/} -w

  To CREATE partitions on an empty device:
  ${0##*/} -p

  To CHECK and UPDATE /etc/fstab entry
  ${0##*/} -f

  To REPLACE devices in ZFS Pools (replace old partitions with new ones):
  ${0##*/} -r

  To REPLACE Swap device in MDADM RAID Configuration
  ${0##*/} -s
  "
}

# ---[ Attempt Best Guess of Device Name ]------------------------------------
__guess_device_name() {
  #  Find the ones which match device types we look for
  local DEVICE_LIST=$({{lsblk_device_command}})
  local DEVICE_COUNT=0

  echo Trying to determine name of possible new device....
  echo
  for device in $DEVICE_LIST
  do
    # Possible match would be a device which has no partitions?
    if [ "$(ls -l /dev/disk/by-id | grep -c ${device})" == "1" ]; then
      ls -l /dev/disk/by-id | awk "/${device}\$/{print \$9}"
      DEVICE_COUNT=$((DEVICE_COUNT+1))
    fi
  done
  
  echo
  case $DEVICE_COUNT in
    0)
      echo "ERROR: Unable to detect or suggest new device.  If new device has"
      echo "       existing partitions, this script will not suggest it.  You"
      echo "       will have to determine which device is the correct one to"
      echo "       use and update this script to use it."
      return 1
    ;;
    1)
      echo "Confirm the above device is correct and then update this script to use it."
      return 0
    ;;
    *)
      echo "$DEVICE_COUNT device(s) found, you will need to determine which is"
      echo "the correct device and update this script to use it."
      return 0
    ;;
  esac
}
# ---------------------------------------------------------------------------

# ---[ Check Block Device is Valid ]-----------------------------------------
__check_block_device() {
  if [[ -b ${DISK_DEVICE} ]]; then
    # Make sure a partition was not specified
    if (echo ${DISK_DEVICE} | grep -q "\-part[0-9]"); then
      echo "DISK_DEVICE cannot be set to a partition."
      echo "${DISK_DEVICE} is not a valid block device."  
    else
      echo "${DISK_DEVICE} is a valid block device."
      echo
      return 0
    fi
  else
    echo "${DISK_DEVICE} is not a valid block device."
    echo
    echo "You must update the script and to use a valid device located in:"
    echo "/dev/disk/by-id"
    return 1
  fi
}
# ---------------------------------------------------------------------------

# ---[ Check for Existing Partitions ]---------------------------------------
__check_device_for_partitions() {
  if ls ${DISK_DEVICE}-part? &> /dev/null; then
      echo "Partitions detected:"
      echo
      ls -l ${DISK_DEVICE}-part? | awk '/-part?/{print $9}'
      echo
      return 1
  else
      echo "No partitions detected."
      return 0
    fi
}
# ---------------------------------------------------------------------------

# ---[ Wipe Partitions ]-----------------------------------------------------
__partition_wipe()
{
  if [ "$ENABLE_PARTITION_WIPE" == "TRUE" ]; then
    if ! __check_device_for_partitions; then   # only run if partitions detected.
      mdadm --zero-superblock --force ${DISK_DEVICE}
      if [ $? -ne 0 ]; then 
        echo "FAILED: mdadm --zero-superblock --force ${DISK_DEVICE}"
      else
        echo "PASSED: mdadm --zero-superblock --force ${DISK_DEVICE}"
      fi
      echo
      mdadm --zero-superblock --force ${DISK_DEVICE}${SWAP_PARTITION}
      if [ $? -ne 0 ]; then 
        echo "FAILED: mdadm --zero-superblock --force ${DISK_DEVICE}${SWAP_PARTITION}"
      else
        echo "PASSED: mdadm --zero-superblock --force ${DISK_DEVICE}${SWAP_PARTITION}"
      fi
      echo
      sgdisk --zap-all ${DISK_DEVICE}
      if [ $? -ne 0 ]; then
        echo "FAILED: sgdisk --zap-all ${DISK_DEVICE}"
      else
        echo "PASSED: sgdisk --zap-all ${DISK_DEVICE}"
      fi
    
      if ! __check_device_for_partitions; then   # Partitions still detected?
        return 1
      else
        return 0
      fi
    fi
  else
    echo "
    This script will not delete partitions by default.  You will need to
    manually edit this script and uncomment ENABLE_PARTITION_WIPE and set
    its value to TRUE.
    "
    return 1
  fi
}
# ---------------------------------------------------------------------------

# ---[ Create Partitions ]---------------------------------------------------
__create_disk_partitions() {
  if __check_device_for_partitions; then
    echo
    echo "Creating UEFI Boot Partition"
    sgdisk ${UEFI_PARTITION_FLAGS} ${DISK_DEVICE}
    if [ $? -ne 0 ]; then return 1; fi

    echo "Creating BIOS Boot Partition"
    sgdisk ${BIOS_PARTITION_FLAGS} ${DISK_DEVICE}
    if [ $? -ne 0 ]; then return 1; fi

    {% if enable_swap_partitions|default(true)|bool == true %}
    echo "Creating Swap Partition"
    sgdisk ${SWAP_PARTITION_FLAGS} ${DISK_DEVICE}
    if [ $? -ne 0 ]; then return 1; fi
    {% else %}
    # NOTE: SWAP Partitions Were not enabled, thus not created.
    {% endif %}

    echo "Creating Boot Pool Partition"
    sgdisk ${BOOT_POOL_PARTITION_FLAGS} ${DISK_DEVICE}
    if [ $? -ne 0 ]; then return 1; fi

    echo "Creating Root Pool Partition"
    sgdisk ${ROOT_POOL_PARTITION_FLAGS} ${DISK_DEVICE}
    if [ $? -ne 0 ]; then return 1; fi
  else
    # Error - pre-existing partitions detected
    echo
    echo "Unable to create partitions, do you need to wipe partitions first?"
    return 1
  fi
}
# ---------------------------------------------------------------------------

# ---[ Create EFI Filesystem on Partition 1 ]--------------------------------
__create_efi_filesystem() {
  echo "Creating EFI filesystems on "${BIOS_PARTITION}" partition"
  mkdosfs -F 32 -s 1 -n EFI ${DISK_DEVICE}${BIOS_PARTITION}
  return $?
}
# ---------------------------------------------------------------------------

# ---[ Check if /etc/fstab is clean or needs to be updated ]-----------------
__check_fstab_file() {
  # UUID of new device
  local UUID=$(blkid -s UUID -o value ${DISK_DEVICE}${BIOS_PARTITION})
  local RET_VAL=1  # Assume itr will return an error

  if [[ -z $UUID ]]; then
    # No UUID partition partition 1 no created??
    echo ERROR: Unable to detect UUID for ${DISK_DEVICE}${BIOS_PARTITION}
    echo 
    echo Check that partitions have been created before attempting to update /etc/fstab file.
    echo
  else
    # See if this UUID Exists in /etc/fstab
    if grep -q "^UUID=${UUID}" /etc/fstab; then
      echo
      echo Device ${DISK_DEVICE} 
      echo With UUID: ${UUID} is found in /etc/fstab, no action needed.
      echo
      echo Entry found:
      grep "^UUID=${UUID}" /etc/fstab
      RET_VAL=0
    else
      echo
      echo Device ${DISK_DEVICE} 
      echo With UUID: ${UUID} is not found in /etc/fstab
      
      local TMP_UUID_FILE=/tmp/fstab_uuids.txt

      # Create a temp copy all existing UUID entries within /etc/fstab
      cat /etc/fstab | grep "^UUID=.*/boot/efi.*" > $TMP_UUID_FILE

      # Loop through devices with a "-part1"
      for device in $(ls -l /dev/disk/by-id | awk "/${BIOS_PARTITION}/{print \$9}")
      do
        DEVICE_UUID=$(blkid -s UUID -o value /dev/disk/by-id/${device})
        
        # Only look at DEVICE_UUID different than new device
        if [ "$DEVICE_UUID" != "$UUID" ]; then
          # Remove existing devices, what's left should be the one to replace
          sed -i "/$DEVICE_UUID/d" $TMP_UUID_FILE
        fi
      done

      # If zero byte file, then no new device has been added
      if [ -s $TMP_UUID_FILE ]; then

        # Make sure only one line left in temp check file
        local LINES_LEFT=$(cat $TMP_UUID_FILE | wc -l)

        if [ "$ENABLE_FSTAB_FILE_UPDATES" == "TRUE" ]; then
          if [ $LINES_LEFT -ne 1 ]; then
            echo
            echo "ERROR: More than possible entry to update detected."
            echo
            cat $TMP_UUID_FILE
            echo 
            echo "This script can not determine which needs to be updated."
            echo "NO CHANGES HAVE BEEN MADE."
          else
            OLD_UUID=$(cat $TMP_UUID_FILE | awk '/^UUID=.* /{print $1}')
            echo 
            echo "Attempting /etc/fstab update of ${OLD_UUID} to ${UUID}"
            echo 
            sed -i "s/^${OLD_UUID}/UUID=${UUID}/g" /etc/fstab
            RET_VAL=$?
          fi
        else
          if [ "$ENABLE_FSTAB_FILE_UPDATES" != "INPROC" ]; then
            echo
            echo "This script will not update your /etc/fstab file automatically."
            echo "You need to update the value manually, or if you want this script"
            echo "to attempt the update your /etc/fstab file then uncomment"
            echo "ENABLE_FSTAB_FILE_UPDATES and set its value to TRUE."
          fi

          if [ $LINES_LEFT -ne 1 ]; then
            echo
            echo "WARNING: More than one possible entry to update detected."
            echo
            cat $TMP_UUID_FILE
            echo 
            echo "Update one of the above to this UUID=${UUID} and then run this script again."
            RET_VAL=0
          else
            echo
            echo "This could be the entry to update in /etc/fstab"
            cat $TMP_UUID_FILE
            echo 
            echo "Change above to this: UUID=${UUID} and then run this script again."
            RET_VAL=0
          fi
          echo
          rm $TMP_UUID_FILE
          return $RET_VAL
        fi
      else
        echo
        echo Unable to determine the device to update in /etc/fstab
        return 1
      fi
    fi
  fi
}
# ---------------------------------------------------------------------------

# ---[ Replace Pool Device ]-------------------------------------------------
__replace_pool_device() {
  local POOL_STATUS=$(zpool status $1 | awk '/state:/{print $2}')
  local OLD_DEV=$(zpool status $1 | awk '/ UNAVAIL /{print $1'})
  local OLD_NAME=$(zpool status $1 | awk '/ UNAVAIL /{print $7'})

  # Make sure Pool is in DEGRADED state
  if [ "$POOL_STATUS" == "DEGRADED" ]; then
    echo 
    echo "Pool: \"$1\" shows ${POOL_STATUS} state"
    
    if [ ! -z $OLD_DEV ]; then
      echo "Old Device Placeholder: ${OLD_DEV}"
      echo "Old Device Name: ${OLD_NAME}"
      echo "New Device Name: ${DISK_DEVICE}$2"

      zpool replace $1 ${OLD_DEV} ${DISK_DEVICE}$2
      if [ $? -eq 0 ]; then
        echo
        echo "Rebuild of \"$1\" Started:"
        POOL_STATUS=$(zpool status $1 | awk '/state:/{print $2}')
        while [ "$POOL_STATUS" == "DEGRADED" ]
        do
          ACTION=$(zpool status $1 | grep "action:")
          PROGRESS=$(zpool status $1 | grep "resilvered,")
          echo ${ACTION} ${PROGRESS}
          sleep 30
          POOL_STATUS=$(zpool status $1 | awk '/state:/{print $2}')
        done

        zpool status $1 | grep "scan: resilvered"

        return 0
      else
        echo
        echo "ERROR: zpool replace returned unexpected value."
        return 1
      fi

    else
      echo
      echo "ERROR: Unable to detect old device to replace. It should have UNAVAIL status".
      return 1
    fi
  else
    echo "NOTE Pool \"$1\" is not DEGRADED, nothing to do."
    return 0
  fi
}
# ---------------------------------------------------------------------------

# ---[ Replace ZFS Devices ]-------------------------------------------------
__replace_zfs_devices() {
  # Attempt work on BOOT Pool
  if (__replace_pool_device ${ZFS_BPOOL_NAME} ${BOOT_PARTITION}); then
    echo DONE: ${ZFS_BPOOL_NAME}
  else
    echo FAIL: ${ZFS_BPOOL_NAME}
  fi
  echo
  # Attempt work on ROOT Pool
  if (__replace_pool_device $ZFS_RPOOL_NAME ${ROOT_PARTITION}); then
      echo DONE: $ZFS_RPOOL_NAME
   else
     echo FAIL: $ZFS_RPOOL_NAME
  fi
}
# ---------------------------------------------------------------------------

# ---[ Replace MDADM Swap Device ]------------------------------------------
__replaced_mdadm_swap_device() {
  if [ -b ${MDADM_SWAP_DEVICE} ]; then
    local MDADM_RAID_LEVEL=$(mdadm -v --detail ${MDADM_SWAP_DEVICE} | awk '/Raid Level : /{print $4}')
    local MDADM_RAID_STATE=$(mdadm -v --detail ${MDADM_SWAP_DEVICE} | awk '/State : /{print substr($0, index($0,$3))}' | awk '{$1=$1};1')

    if (mdadm -q -E ${DISK_DEVICE} &>/dev/null); then
      echo "MDADM Device: \"${MDADM_SWAP_DEVICE}\" is a valid block device, configured for \"${MDADM_RAID_LEVEL}\" has state \"${MDADM_RAID_STATE}\""
      if [ "${MDADM_RAID_STATE}" != "clean" ]; then

        mdadm --manage ${MDADM_SWAP_DEVICE} --add ${DISK_DEVICE}${SWAP_PARTITION}
        if [ $? -eq 0 ]; then
          while [ "${MDADM_RAID_STATE}" != "clean" ]
          do 
            mdadm -v --detail ${MDADM_SWAP_DEVICE} | grep "Rebuild Status"
            sleep 5
            MDADM_RAID_STATE=$(mdadm -v --detail ${MDADM_SWAP_DEVICE} | awk '/State : /{print substr($0, index($0,$3))}' | awk '{$1=$1};1')
          done
          return 0
        else
          echo
          echo "mdadm --add return unexpected result."
          return 1
        fi
      else
        echo
        echo "Nothing to do."
        return 0
      fi
    else
      echo
      echo "ERROR: Device ${DISK_DEVICE}"
      echo "       has no super-block and is not part of any mdm RAID Configuration."
    fi
  else
    echo
    echo "ERROR: MDADM Device: ${MDADM_SWAP_DEVICE} is not valid block device."
  fi
}
# ---------------------------------------------------------------------------

# ---[ Process Parameters ]--------------------------------------------------
if [ $# -gt 0 ]; then
  while getopts "dcwpfrs" opt; do
    case "$opt" in
      d|D)
        __guess_device_name
      ;;
      c|C)
        if __check_block_device; then
          if ! __check_device_for_partitions; then  # show message if detected
            echo "You must remove partitions from this device to use this script."
            echo "If this was not expected did you specify the wrong device?"
          fi
        fi
      ;;
      w|W)
        if __partition_wipe; then
          echo
          echo "Completed Successfully"
        fi
      ;;
      p|P)
        if __check_block_device; then
          if __create_disk_partitions; then
            if __create_efi_filesystem; then
              echo
              echo "Completed Successfully"
            else
              echo
              echo "ERROR: Create EFI Filesystem Failed"
              exit 3
            fi
          else
            echo
            echo "ERROR: Create Partitions Failed"
            exit 3
          fi
        fi
      ;;
      f|F)
        if __check_block_device; then
          if __check_fstab_file; then
            # If automated updated was successful, set as in-progress
            # and run one more time to validate.
            if [ "$ENABLE_FSTAB_FILE_UPDATES" == "TRUE" ]; then
              ENABLE_FSTAB_FILE_UPDATES=INPROC
              echo "Update Completed, running again to validate:"
              __check_fstab_file
            fi
          else
            echo
            echo "ERROR: Unexpected error detected."
            exit 3
          fi
        fi
      ;;
      r|R)
        if __check_block_device; then
          if __replace_zfs_devices; then
            echo Completed
          else
            echo Failed.
          fi
        fi
      ;;
      s|S)
        if __check_block_device; then
          if __replaced_mdadm_swap_device; then
            echo Completed.
          else
            echo Failed.
          fi
        fi
      ;;
      \?) # Invalid option passed.
        __usage
        exit 1
      ;;
      :)
        echo "ERROR: Option -$OPTARG requires and argument"
        __usage
        exit 1
      ;;
      *)
        echo "ERROR: Unknown Option: $opt"
        __usage
        exit 1
      ;;
    esac
  done
else  # No Paramters passed
  __usage
  exit 1
fi

exit 0