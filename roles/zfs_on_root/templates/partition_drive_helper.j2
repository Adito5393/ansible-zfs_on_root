#!/bin/bash
# NAME       : partition_drive_helper.sh
# 
# DESCRIPTION: This is a helper script generated by the Ansible ZFS on Root
#           script showing how the partitions on your drivers were created.
#
#           Should you need to replace a drive or add new drives, you would
#           likely want to partition them in the same way as your existing 
#           drives.
# AUTHOR     : Richard J. Durso
# DATE       : 08/11/2020
# VERSION    : 0.10
#############################################################################

# ---------------------------------------------------------------------------
# Define device name to use:
DISK_DEVICE=/dev/disk/by-id/PUT_YOUR_DEVICE_NAME_HERE
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------
# DANGER: This script does not wipe existing disk partitions.  However, Should
#         you choose to accept this mission, you must uncomment the value
#         below and set it to TRUE.

# ENABLE_PARTITION_WIPE=FALSE
# ---------------------------------------------------------------------------

# ---------------------------------------------------------------------------
# WARNING: This script does not update your /etc/fstab to use new UUID values
#          for a new device being added.  This should be manually performed.
#          However, if you want the script to attempt it, you must uncomment
#          the value below and set it to TRUE.

# ENABLE_FSTAB_FILE_UPDATES=FALSE
ENABLE_FSTAB_FILE_UPDATES=TRUE
# ---------------------------------------------------------------------------

# ---[ Usage Statement ]-----------------------------------------------------
__usage() {
  echo "
  zfs_on_root Partitioning Helper Script
  ---------------------------------------------------------------------------
  The flags set in this script were specific to this installation at the time
  the zfs_on_root script was executed.  This should not be executed on other
  systems.

  DISK_DEVICE set to: ${DISK_DEVICE}

  To check device exists and has no partitions:
  ${0##*/} -c

  To WIPE, DELETE, REMOVE, DESTROY, ZAP, ELIMINATE device partitions:
  ${0##*/} -w

  To CREATE partitions on an empty device:
  ${0##*/} -p

  To CHECK /etc/fstab entry
  ${0##*/} -f
  "
}

# ---[ Check Block Device is Valid ]-----------------------------------------
__check_block_device() {
  if [[ -b ${DISK_DEVICE} ]]; then
    echo ${DISK_DEVICE} is a valid block device.
    echo
    return 0
  else
    echo ${DISK_DEVICE} is not a valid block device.
    echo
    echo You must update the script and to use a valid device located in:
    echo "/dev/disk/by-id"
    return 1
  fi
}
# ---------------------------------------------------------------------------

# ---[ Check for Existing Partitions ]---------------------------------------
__check_device_for_partitions() {
  if __check_block_device; then
    if ls ${DISK_DEVICE}-part? &> /dev/null; then
        echo Partitions detected:
        echo
        ls -l ${DISK_DEVICE}-part? | awk '/-part?/{print $9}'
        echo
        return 1
    else
        echo No partitions detected.
        return 0
      fi
  fi
}
# ---------------------------------------------------------------------------

# ---[ Wipe Partitions ]-----------------------------------------------------
__partition_wipe()
{
  if [ "$ENABLE_PARTITION_WIPE" == "TRUE" ]; then
    if ! __check_device_for_partitions; then   # only run if partitions detected.
      mdadm --zero-superblock --force ${DISK_DEVICE}
      if [ $? -ne 0 ]; then 
        echo "FAILED: mdadm --zero-superblock --force ${DISK_DEVICE}"
      else
        echo "PASSED: mdadm --zero-superblock --force ${DISK_DEVICE}"
      fi
      echo
      mdadm --zero-superblock --force ${DISK_DEVICE}-part2
      if [ $? -ne 0 ]; then 
        echo "FAILED: mdadm --zero-superblock --force ${DISK_DEVICE}-part2"
      else
        echo "PASSED: mdadm --zero-superblock --force ${DISK_DEVICE}-part2"
      fi
      echo
      sgdisk --zap-all ${DISK_DEVICE}
      if [ $? -ne 0 ]; then
        echo "FAILED: sgdisk --zap-all ${DISK_DEVICE}"
      else
        echo "PASSED: sgdisk --zap-all ${DISK_DEVICE}"
      fi
    
      if ! __check_device_for_partitions; then   # Partitions still detected?
        return 1
      else
        return 0
      fi
    fi
  else
    echo "
    This script will not delete partitions by default.  You will need to
    manually edit this script and uncomment ENABLE_PARTITION_WIPE and set
    its value to TRUE.
    "
    return 1
  fi
}
# ---------------------------------------------------------------------------

# ---[ Create Partitions ]---------------------------------------------------
__create_disk_partitions() {
  if __check_device_for_partitions; then
    echo
    echo "Creating UEFI Boot Partition"
    sgdisk {{ uefi_partition_flags }} ${DISK_DEVICE}
    if [ $? -ne 0 ]; then return 1; fi

    echo "Creating BIOS Boot Partition"
    sgdisk {{ bios_partition_flags }} ${DISK_DEVICE}
    if [ $? -ne 0 ]; then return 1; fi

    {% if enable_swap_partitions|default(true)|bool == true %}
    echo "Creating Swap Partition"
    sgdisk {{(boot_pool_type == 'raidz')|ternary(raidz_multi_disk_swap_flags, single_disk_or_mirror_swap_flags)}} ${DISK_DEVICE}
    if [ $? -ne 0 ]; then return 1; fi
    {% else %}
    # NOTE: SWAP Partitions Were not enabled, thus not created.
    {% endif %}

    echo "Creating Boot Pool Partition"
    sgdisk {{(boot_pool_type == 'raidz')|ternary(raidz_multi_disk_boot_partition_flags,single_disk_or_mirror_boot_partition_flags)}} ${DISK_DEVICE}
    if [ $? -ne 0 ]; then return 1; fi

    echo "Creating Root Pool Partition"
    sgdisk {{ root_partition_flags }} ${DISK_DEVICE}
    if [ $? -ne 0 ]; then return 1; fi
  else
    # Error - pre-existing partitions detected
    echo
    echo "Unable to create partitions, do you need to wipe partitions first?"
    return 1
  fi
}
# ---------------------------------------------------------------------------

# ---[ Create EFI Filesystem on Partition 1 ]--------------------------------
__create_efi_filesystem() {
  echo "Creating EFI filesystems on "-part1" partition"
  mkdosfs -F 32 -s 1 -n EFI ${DISK_DEVICE}-part1
  return $?
}
# ---------------------------------------------------------------------------

# ---[ Check if /etc/fstab is clean or needs to be updated ]-----------------
__check_fstab_file() {
  # UUID of new device
  UUID=$(blkid -s UUID -o value ${DISK_DEVICE}-part1)
  if [[ -z $UUID ]]; then
    # No UUID partition partition 1 no created??
    echo ERROR: Unable to detect UUID for ${DISK_DEVICE}-part1
    echo 
    echo Check that partitions have been created before attempting to update /etc/fstab file.
    echo
  else
    # See if this UUID Exists in /etc/fstab
    if grep -q "^UUID=${UUID}" /etc/fstab; then
      echo
      echo Device ${DISK_DEVICE} 
      echo With UUID: ${UUID} is found in /etc/fstab, no action needed.
      echo
      echo Entry found:
      grep "^UUID=${UUID}" /etc/fstab
      return 0
    else
      echo
      echo Device ${DISK_DEVICE} 
      echo With UUID: ${UUID} is not found in /etc/fstab
      
      TMP_UUID_FILE=/tmp/fstab_uuids.txt

      # Create a temp copy all existing UUID entries within /etc/fstab
      cat /etc/fstab | grep "^UUID=.*/boot/efi.*" > $TMP_UUID_FILE

      # Loop through devices with a "-part1"
      for device in $(ls -l /dev/disk/by-id | awk '/-part1/{print $9}')
      do
        DEVICE_UUID=$(blkid -s UUID -o value /dev/disk/by-id/${device})
        
        # Only look at DEVICE_UUID different than new device
        if [ "$DEVICE_UUID" != "$UUID" ]; then
          # Remove existing devices, what's left should be the one to replace
          sed -i "/$DEVICE_UUID/d" $TMP_UUID_FILE
        fi
      done

      # If zero byte file, then no new device has been added
      if [ -s $TMP_UUID_FILE ]; then

        # Make sure only one line left in temp check file
        LINES_LEFT=$(cat $TMP_UUID_FILE | wc -l)

        if [ "$ENABLE_FSTAB_FILE_UPDATES" == "TRUE" ]; then
          if [ $LINES_LEFT -ne 1 ]; then
            echo
            echo ERROR: More than possible entry to update detected.
            echo
            cat $TMP_UUID_FILE
            echo 
            echo This script can not determine which needs to be updated.
            echo NO CHANGES HAVE BEEN MADE.
          else
            OLD_UUID=$(cat $TMP_UUID_FILE | awk '/^UUID=.* /{print $1}')
            echo 
            echo "Attempting /etc/fstab update of ${OLD_UUID} to ${UUID}"
            echo 
            sed -i "s/^${OLD_UUID}/UUID=${UUID}/g" /etc/fstab
            return $?
          fi
        else
          if [ "$ENABLE_FSTAB_FILE_UPDATES" != "INPROC" ]; then
            echo This script will not update your /etc/fstab file automatically.
            echo You need to update the value manually, or if you want this script
            echo to attempt the update your /etc/fstab file then uncomment 
            echo ENABLE_FSTAB_FILE_UPDATES and set its value to TRUE.
          fi

          if [ $LINES_LEFT -ne 1 ]; then
            echo
            echo WARNING: More than possible entry to update detected.
            echo
            cat $TMP_UUID_FILE
            echo 
            echo Update one of the above to this UUID=${UUID} and then run this script again.
          else
            echo
            echo This could be the entry to update in /etc/fstab
            cat $TMP_UUID_FILE
            echo 
            echo Change above to this UUID=${UUID} and then run this script again.
          fi
          echo
          rm $TMP_UUID_FILE
          return 1
        fi
      else
        echo
        echo Unable to determine the device to update in /etc/fstab
        return 1
      fi
    fi
  fi
}
# ---------------------------------------------------------------------------

# ---[ Process Parameters ]--------------------------------------------------
if [ $# -gt 0 ]; then
  while getopts "cwpf" opt; do
    case "$opt" in
      c|C)
        if ! __check_device_for_partitions; then  # show message if detected
          echo "You must remove partitions from this device to use this script."
          echo "If this was not expected did you specify the wrong device?"
        fi
      ;;
      w|W)
        if __partition_wipe; then
          echo
          echo "Completed Successfully"
        fi
      ;;
      p|P)
        if __create_disk_partitions; then
          if __create_efi_filesystem; then
            echo
            echo "Completed Successfully"
          else
            echo
            echo "ERROR: Create EFI Filesystem Failed"
            exit 3
          fi
        else
          echo
          echo "ERROR: Create Partitions Failed"
          exit 3
        fi
      ;;
      f|F)
        if __check_fstab_file; then
           # If automated updated was successful, set as in-progress
           # and run one more time to validate.
           if [ "$ENABLE_FSTAB_FILE_UPDATES" == "TRUE" ]; then
             ENABLE_FSTAB_FILE_UPDATES=INPROC
             echo "Update Completed, running again to validate:
             __check_fstab_file
          fi
        else
          echo
          echo "ERROR: Unexpected error detected."
          exit 3
        fi
      ;;
      \?) # Invalid option passed.
        __usage
        exit 1
      ;;
      :)
        echo "ERROR: Option -$OPTARG requires and argument"
        __usage
        exit 1
      ;;
      *)
        echo "ERROR: Unknown Option: $opt"
        __usage
        exit 1
      ;;
    esac
  done
else  # No Paramters passed
  __usage
  exit 1
fi

exit 0